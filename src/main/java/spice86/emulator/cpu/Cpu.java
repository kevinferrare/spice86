package spice86.emulator.cpu;

import static spice86.utils.ConvertUtils.int16;
import static spice86.utils.ConvertUtils.int8;
import static spice86.utils.ConvertUtils.uint16;
import static spice86.utils.ConvertUtils.uint32;
import static spice86.utils.ConvertUtils.uint8;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import spice86.emulator.callback.CallbackHandler;
import spice86.emulator.errors.InvalidOperationException;
import spice86.emulator.errors.UnhandledOperationException;
import spice86.emulator.function.CallType;
import spice86.emulator.function.FunctionHandler;
import spice86.emulator.ioports.IOPortDispatcher;
import spice86.emulator.machine.Machine;
import spice86.emulator.memory.Memory;
import spice86.emulator.memory.MemoryUtils;
import spice86.utils.ConvertUtils;

/**
 * Implementation of a 8086 CPU.<br/>
 * It has some 80186, 80286 and 80386 instructions as some program use them.<br/>
 * It also has some x87 FPU instructions to support telling the programs that x87 is not supported :)<br/>
 * Some docs that helped the implementation:
 * <ul>
 * <li>Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and http://ref.x86asm.net/coder32.html</li>
 * <li>Instructions implementation details: https://www.felixcloutier.com/x86/</li>
 * <li>Pure 8086 instructions: https://jbwyatt.com/253/emu/8086_instruction_set.html</li>
 * </ul>
 */
@SuppressWarnings({
    // Some strings are duplicated, this is because some opcodes encode similar instructions. And the only way in this
    // class to know what is the opcode is to look at the log statement (did not add comments for this as this would be
    // redundant).
    "java:S1192",
    // Some switches do not have a lot of case statements, that's because the rest is not implemented (yet).
    "java:S1301",
    // Switch has a lot of arguments, this class is essentially a big switch with one case per opcode.
    "java:S1479",
    // Cognitive complexity is high when you have one big switch
    "java:S3776",
    // We actually check whether log level is enabled / disabled via another method and sonar does not detect it.
    "java:S2629" })
public class Cpu {
  private static final Logger LOGGER = LoggerFactory.getLogger(Cpu.class);

  // Extract regIndex from opcode
  private static final int REG_INDEX_MASK = 0b111;
  private static final Set<Integer> PREFIXES_OPCODES = new HashSet<>(
      Arrays.asList(0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0xF0, 0xF2, 0xF3));
  private static final Set<Integer> STRING_OPCODES =
      new HashSet<>(Arrays.asList(0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F));

  private Machine machine;
  private State state;
  private Memory memory;
  private ModRM modRM;
  private Alu alu;
  private CallbackHandler callbackHandler;
  private IOPortDispatcher ioPortDispatcher;
  private FunctionHandler functionHandler;
  private FunctionHandler functionHandlerInExternalInterrupt;
  // Not the same depending on whether we are processing an external interrupt or not (call stack is not the same)
  private FunctionHandler functionHandlerInUse;

  // Value used to read parts of the instruction. CPU uses this internally and adjusts IP after instruction execution is
  // done.
  private int internalIp;
  private boolean running = true;
  // interrupt not generated by the code
  private Integer externalInterruptVectorNumber;
  // When true will crash if an interrupt targets code at 0000:0000
  private boolean errorOnUninitializedInterruptHandler;
  private Boolean forceLog;

  public Cpu(Machine machine) {
    this.machine = machine;
    this.memory = machine.getMemory();
    this.state = new State();
    this.alu = new Alu(state);
    this.modRM = new ModRM(machine, this);
    this.functionHandler = new FunctionHandler();
    this.functionHandlerInExternalInterrupt = new FunctionHandler();
    this.functionHandlerInUse = functionHandler;
  }

  public State getState() {
    return state;
  }

  public Alu getAlu() {
    return alu;
  }

  public boolean isRunning() {
    return running;
  }

  public void setRunning(boolean running) {
    this.running = running;
  }

  public void setCallbackHandler(CallbackHandler callbackHandler) {
    this.callbackHandler = callbackHandler;
  }

  public void setIoPortDispatcher(IOPortDispatcher ioPortDispatcher) {
    this.ioPortDispatcher = ioPortDispatcher;
  }

  public FunctionHandler getFunctionHandler() {
    return this.functionHandler;
  }

  public FunctionHandler getFunctionHandlerInExternalInterrupt() {
    return functionHandlerInExternalInterrupt;
  }

  public FunctionHandler getFunctionHandlerInUse() {
    return functionHandlerInUse;
  }

  public void setForceLog(boolean forceLog) {
    this.forceLog = forceLog;
  }

  public void externalInterrupt(int vectorNumber) {
    // hack: do not let the timer overwrite keyboard.
    if (this.externalInterruptVectorNumber == null || this.externalInterruptVectorNumber != 9) {
      this.externalInterruptVectorNumber = vectorNumber;
    }
  }

  public void setErrorOnUninitializedInterruptHandler(boolean errorOnUninitializedInterruptHandler) {
    this.errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
  }

  private void addCurrentInstructionPrefix(Supplier<String> getLog) {
    // Optimization, do not calculate the log if it is not used
    if (isLoggingEnabled()) {
      state.addCurrentInstructionPrefix(getLog.get());
    }
  }

  private void setCurrentInstructionName(Supplier<String> getLog) {
    // Optimization, do not calculate the log if it is not used
    if (isLoggingEnabled()) {
      state.setCurrentInstructionName(getLog.get());
    }
  }

  private boolean isLoggingEnabled() {
    if (forceLog == null) {
      return LOGGER.isDebugEnabled();
    }
    return forceLog;
  }

  public void executeNextInstruction() throws InvalidOperationException {
    internalIp = state.getIP();
    String stateString = "";
    if (isLoggingEnabled()) {
      stateString = state.toString();
      state.resetCurrentInstructionPrefix();
      state.setCurrentInstructionName("");
    }
    int opcode = processPrefixes();
    if (isLoggingEnabled()) {
      LOGGER.debug("Before execution: opcode {} {} ", ConvertUtils.toHex8(opcode),
          stateString);
    }
    if (state.getContinueZeroFlagValue() != null && isStringOpcode(opcode)) {
      // continueZeroFlag is either true or false if a rep prefix has been encountered
      processRep(opcode);
    } else {
      execOpcode(opcode);
    }
    if (isLoggingEnabled()) {
      String instructionName = state.getCurrentInstructionNameWithPrefix();
      LOGGER.debug("After execution of {} {}", instructionName, state);
    }
    state.clearPrefixes();
    state.incCycles();
    handleExternalInterrupt();
    state.setIP(internalIp);
  }

  private void handleExternalInterrupt() throws UnhandledOperationException {
    if (externalInterruptVectorNumber == null || !state.getInterruptFlag()) {
      return;
    }
    if (isLoggingEnabled()) {
      LOGGER.debug("Interrupted!, int {}", externalInterruptVectorNumber);
    }
    interrupt(externalInterruptVectorNumber, true);
    externalInterruptVectorNumber = null;
  }

  private void processRep(int opcode) throws InvalidOperationException {
    // repeat while zero flag is false for REPNZ (last bit is 0)
    // or while zero flag is true for REPZ (last bit is 1)
    boolean continueZeroFlagValue = state.getContinueZeroFlagValue();
    // For some instructions, zero flag is not to be checked
    boolean checkZeroFlag = isStringOpUpdatingFlags(opcode);
    int cx = state.getCX();
    while (cx != 0) {
      // re-set the segment override that may have been cleared. No need to reset ip
      // as string instructions don't modify it and are only one byte.
      processString(opcode);
      cx = cx - 1;

      if (LOGGER.isTraceEnabled()) {
        LOGGER.trace("REP {} Loop, CX={}, ZF={}, checkZeroFlag={}, continueZF={}",
            state.getCurrentInstructionNameWithPrefix(),
            ConvertUtils.toHex(cx), state.getZeroFlag(), checkZeroFlag, continueZeroFlagValue);
      }
      // Not all the string operations require checking the zero flag...
      if (checkZeroFlag && state.getZeroFlag() != continueZeroFlagValue) {
        break;
      }
    }
    state.setCX(cx);
  }

  private int processPrefixes() throws InvalidOperationException {
    int opcode = nextUint8();
    while (isPrefix(opcode)) {
      processPrefix(opcode);
      opcode = nextUint8();
    }
    return opcode;
  }

  private void processPrefix(int opcode) throws InvalidOperationException {
    switch (opcode) {
      case 0x26 -> {
        addCurrentInstructionPrefix(() -> "ES:");
        state.setSegmentOverrideIndex(SegmentRegisters.ES_INDEX);
      }
      case 0x2E -> {
        addCurrentInstructionPrefix(() -> "CS:");
        state.setSegmentOverrideIndex(SegmentRegisters.CS_INDEX);
      }
      case 0x36 -> {
        addCurrentInstructionPrefix(() -> "SS:");
        state.setSegmentOverrideIndex(SegmentRegisters.SS_INDEX);
      }
      case 0x3E -> {
        addCurrentInstructionPrefix(() -> "DS:");
        state.setSegmentOverrideIndex(SegmentRegisters.DS_INDEX);
      }
      case 0x64 -> {
        addCurrentInstructionPrefix(() -> "FS:");
        state.setSegmentOverrideIndex(SegmentRegisters.FS_INDEX);
      }
      case 0x65 -> {
        addCurrentInstructionPrefix(() -> "GS:");
        state.setSegmentOverrideIndex(SegmentRegisters.GS_INDEX);
      }
      case 0xF0 -> addCurrentInstructionPrefix(() -> "LOCK");
      case 0xF2, 0xF3 -> { // REPNZ, REPZ
        boolean continueZeroFlagValue = (opcode & 1) == 1;
        state.setContinueZeroFlagValue(continueZeroFlagValue);
        addCurrentInstructionPrefix(() -> "REP" + (continueZeroFlagValue ? "Z" : ""));
      }
      default -> throw new InvalidOperationException(machine,
          "processPrefix Called with a non prefix opcode " + opcode);
    }
  }

  private void execOpcode(int opcode) throws InvalidOperationException {
    switch (opcode) {
      case 0x00 -> {
        setCurrentInstructionName(() -> "ADD rmb rb");
        modRM.read();
        modRM.setRm8(alu.add8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x01 -> {
        setCurrentInstructionName(() -> "ADD rmw rw");
        modRM.read();
        modRM.setRm16(alu.add16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x02 -> {
        setCurrentInstructionName(() -> "ADD rb rmb");
        modRM.read();
        modRM.setR8(alu.add8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x03 -> {
        setCurrentInstructionName(() -> "ADD rw rmw");
        modRM.read();
        modRM.setR16(alu.add16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x04 -> {
        setCurrentInstructionName(() -> "ADD AL ib");
        state.setAL(alu.add8(state.getAL(), nextUint8()));
      }
      case 0x05 -> {
        setCurrentInstructionName(() -> "ADD AX iw");
        state.setAX(alu.add16(state.getAX(), nextUint16()));
      }
      case 0x06 -> {
        setCurrentInstructionName(() -> "PUSH ES");
        push(state.getES());
      }
      case 0x07 -> {
        setCurrentInstructionName(() -> "POP ES");
        state.setES(pop());
      }
      case 0x08 -> {
        setCurrentInstructionName(() -> "OR rmb rb");
        modRM.read();
        modRM.setRm8(alu.or8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x09 -> {
        setCurrentInstructionName(() -> "OR rmw rw");
        modRM.read();
        modRM.setRm16(alu.or16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x0A -> {
        setCurrentInstructionName(() -> "OR rb rmb");
        modRM.read();
        modRM.setR8(alu.or8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x0B -> {
        setCurrentInstructionName(() -> "OR rw rmw");
        modRM.read();
        modRM.setR16(alu.or16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x0C -> {
        setCurrentInstructionName(() -> "OR AL ib");
        state.setAL(alu.or8(state.getAL(), nextUint8()));
      }
      case 0x0D -> {
        setCurrentInstructionName(() -> "OR AX iw");
        state.setAX(alu.or16(state.getAX(), nextUint16()));
      }
      case 0x0E -> {
        setCurrentInstructionName(() -> "PUSH CS");
        push(state.getCS());
      }
      case 0x0F -> handleInvalidOpcode(opcode);
      case 0x10 -> {
        setCurrentInstructionName(() -> "ADC rmb rb");
        modRM.read();
        modRM.setRm8(alu.adc8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x11 -> {
        setCurrentInstructionName(() -> "ADC rmw rw");
        modRM.read();
        modRM.setRm16(alu.adc16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x12 -> {
        setCurrentInstructionName(() -> "ADC rb rmb");
        modRM.read();
        modRM.setR8(alu.adc8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x13 -> {
        setCurrentInstructionName(() -> "ADC rw rmw");
        modRM.read();
        modRM.setR16(alu.adc16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x14 -> {
        setCurrentInstructionName(() -> "ADC AL ib");
        state.setAL(alu.adc8(state.getAL(), nextUint8()));
      }
      case 0x15 -> {
        setCurrentInstructionName(() -> "ADC AX iw");
        state.setAX(alu.adc16(state.getAX(), nextUint16()));
      }
      case 0x16 -> {
        setCurrentInstructionName(() -> "PUSH SS");
        push(state.getSS());
      }
      case 0x17 -> {
        setCurrentInstructionName(() -> "POP SS");
        state.setSS(pop());
      }
      case 0x18 -> {
        setCurrentInstructionName(() -> "SBB rmb rb");
        modRM.read();
        modRM.setRm8(alu.sbb8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x19 -> {
        setCurrentInstructionName(() -> "SBB rmw rw");
        modRM.read();
        modRM.setRm16(alu.sbb16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x1A -> {
        setCurrentInstructionName(() -> "SBB rb rmb");
        modRM.read();
        modRM.setR8(alu.sbb8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x1B -> {
        setCurrentInstructionName(() -> "SBB rw rmw");
        modRM.read();
        modRM.setR16(alu.sbb16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x1C -> {
        setCurrentInstructionName(() -> "SBB AL ib");
        state.setAL(alu.sbb8(state.getAL(), nextUint8()));
      }
      case 0x1D -> {
        setCurrentInstructionName(() -> "SBB AX iw");
        state.setAX(alu.sbb16(state.getAX(), nextUint16()));
      }
      case 0x1E -> {
        setCurrentInstructionName(() -> "PUSH DS");
        push(state.getDS());
      }
      case 0x1F -> {
        setCurrentInstructionName(() -> "POP DS");
        state.setDS(pop());
      }
      case 0x20 -> {
        setCurrentInstructionName(() -> "AND rmb rb");
        modRM.read();
        modRM.setRm8(alu.and8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x21 -> {
        setCurrentInstructionName(() -> "AND rmw rw");
        modRM.read();
        modRM.setRm16(alu.and16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x22 -> {
        setCurrentInstructionName(() -> "AND rb rmb");
        modRM.read();
        modRM.setR8(alu.and8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x23 -> {
        setCurrentInstructionName(() -> "AND rw rmw");
        modRM.read();
        modRM.setR16(alu.and16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x24 -> {
        setCurrentInstructionName(() -> "AND AL ib");
        state.setAL(alu.and8(state.getAL(), nextUint8()));
      }
      case 0x25 -> {
        setCurrentInstructionName(() -> "AND AX iw");
        state.setAX(alu.and16(state.getAX(), nextUint16()));
      }
      case 0x26 -> handleInvalidOpcodeBecausePrefix(opcode);
      case 0x27 -> {
        setCurrentInstructionName(() -> "DAA");
        int initialAL = state.getAL();
        boolean initialCF = state.getCarryFlag();
        boolean finalAuxillaryFlag = false;
        boolean finalCarryFlag = false;
        if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag()) {
          state.setAL(state.getAL() + 6);
          finalAuxillaryFlag = true;
        }

        if (initialAL > 0x99 || initialCF) {
          state.setAL(state.getAL() + 0x60);
          finalCarryFlag = true;
        } else {
          finalCarryFlag = false;
        }
        // Undocumented behaviour
        alu.updateFlags8(state.getAL());
        state.setAuxiliaryFlag(finalAuxillaryFlag);
        state.setCarryFlag(finalCarryFlag);
      }
      case 0x28 -> {
        setCurrentInstructionName(() -> "SUB rmb rb");
        modRM.read();
        modRM.setRm8(alu.sub8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x29 -> {
        setCurrentInstructionName(() -> "SUB rmw rw");
        modRM.read();
        modRM.setRm16(alu.sub16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x2A -> {
        setCurrentInstructionName(() -> "SUB rb rmb");
        modRM.read();
        modRM.setR8(alu.sub8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x2B -> {
        setCurrentInstructionName(() -> "SUB rw rmw");
        modRM.read();
        modRM.setR16(alu.sub16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x2C -> {
        setCurrentInstructionName(() -> "SUB AL ib");
        state.setAL(alu.sub8(state.getAL(), nextUint8()));
      }
      case 0x2D -> {
        setCurrentInstructionName(() -> "SUB AX iw");
        state.setAX(alu.sub16(state.getAX(), nextUint16()));
      }
      case 0x2E -> handleInvalidOpcodeBecausePrefix(opcode);
      case 0x2F -> {
        setCurrentInstructionName(() -> "DAS");
        int initialAL = state.getAL();
        boolean initialCF = state.getCarryFlag();
        boolean finalAuxillaryFlag = false;
        boolean finalCarryFlag = false;
        state.setCarryFlag(false);
        if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag()) {
          state.setAL(state.getAL() - 6);
          finalCarryFlag = state.getCarryFlag() || initialCF;
          finalAuxillaryFlag = true;
        }
        if (initialAL > 0x99 || initialCF) {
          state.setAL(state.getAL() - 0x60);
          finalCarryFlag = true;
        }
        // Undocumented behaviour
        alu.updateFlags8(state.getAL());
        state.setAuxiliaryFlag(finalAuxillaryFlag);
        state.setCarryFlag(finalCarryFlag);
      }
      case 0x30 -> {
        setCurrentInstructionName(() -> "XOR rmb rb");
        modRM.read();
        modRM.setRm8(alu.xor8(modRM.getRm8(), modRM.getR8()));
      }
      case 0x31 -> {
        setCurrentInstructionName(() -> "XOR rmw rw");
        modRM.read();
        modRM.setRm16(alu.xor16(modRM.getRm16(), modRM.getR16()));
      }
      case 0x32 -> {
        setCurrentInstructionName(() -> "XOR rb rmb");
        modRM.read();
        modRM.setR8(alu.xor8(modRM.getR8(), modRM.getRm8()));
      }
      case 0x33 -> {
        setCurrentInstructionName(() -> "XOR rw rmw");
        modRM.read();
        modRM.setR16(alu.xor16(modRM.getR16(), modRM.getRm16()));
      }
      case 0x34 -> {
        setCurrentInstructionName(() -> "XOR AL mb");
        state.setAL(alu.xor8(state.getAL(), nextUint8()));
      }
      case 0x35 -> {
        setCurrentInstructionName(() -> "XOR AX mw");
        state.setAX(alu.xor16(state.getAX(), nextUint16()));
      }
      case 0x36 -> handleInvalidOpcodeBecausePrefix(opcode);
      case 0x37 -> {
        setCurrentInstructionName(() -> "AAA");
        boolean finalAuxillaryFlag = false;
        boolean finalCarryFlag = false;
        if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag()) {
          state.setAX(state.getAX() + 0x106);
          finalAuxillaryFlag = true;
          finalCarryFlag = true;
        }
        state.setAL(state.getAL() & 0x0F);
        // Undocumented behaviour
        alu.updateFlags8(state.getAL());
        state.setAuxiliaryFlag(finalAuxillaryFlag);
        state.setCarryFlag(finalCarryFlag);
      }
      case 0x38 -> {
        setCurrentInstructionName(() -> "CMP rmb rb");
        modRM.read();
        alu.sub8(modRM.getRm8(), modRM.getR8());
      }
      case 0x39 -> {
        setCurrentInstructionName(() -> "CMP rmw rw");
        modRM.read();
        alu.sub16(modRM.getRm16(), modRM.getR16());
      }
      case 0x3A -> {
        setCurrentInstructionName(() -> "CMP rb rmb");
        modRM.read();
        alu.sub8(modRM.getR8(), modRM.getRm8());
      }
      case 0x3B -> {
        setCurrentInstructionName(() -> "CMP rw rmw");
        modRM.read();
        alu.sub16(modRM.getR16(), modRM.getRm16());
      }
      case 0x3C -> {
        setCurrentInstructionName(() -> "CMP AL ib");
        alu.sub8(state.getAL(), nextUint8());
      }
      case 0x3D -> {
        setCurrentInstructionName(() -> "CMP AX iw");
        alu.sub16(state.getAX(), nextUint16());
      }
      case 0x3E -> handleInvalidOpcodeBecausePrefix(opcode);
      case 0x3F -> {
        setCurrentInstructionName(() -> "AAS");
        boolean finalAuxillaryFlag = false;
        boolean finalCarryFlag = false;
        if ((state.getAL() & 0x0F) > 9 || state.getAuxiliaryFlag()) {
          state.setAX(state.getAX() - 6);
          state.setAH(state.getAH() - 1);
          finalAuxillaryFlag = true;
          finalCarryFlag = true;
        }
        state.setAL(state.getAL() & 0x0F);
        // Undocumented behaviour
        alu.updateFlags8(state.getAL());
        state.setAuxiliaryFlag(finalAuxillaryFlag);
        state.setCarryFlag(finalCarryFlag);
      }
      case 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47 -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "INC " + state.getRegisters().getRegName(regIndex));
        state.getRegisters().setRegister(regIndex, alu.inc16(state.getRegisters().getRegister(regIndex)));
      }
      case 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "DEC " + state.getRegisters().getRegName(regIndex));
        state.getRegisters().setRegister(regIndex, alu.dec16(state.getRegisters().getRegister(regIndex)));
      }
      case 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57 -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "PUSH " + state.getRegisters().getRegName(regIndex));
        push(state.getRegisters().getRegister(regIndex));
      }
      case 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "POP " + state.getRegisters().getRegName(regIndex));
        state.getRegisters().setRegister(regIndex, pop());
      }
      case 0x60 -> {
        // 80186
        setCurrentInstructionName(() -> "PUSHA");
        int sp = state.getSP();
        push(state.getAX());
        push(state.getCX());
        push(state.getDX());
        push(state.getBX());
        push(sp);
        push(state.getBP());
        push(state.getSI());
        push(state.getDI());
      }
      case 0x61 -> {
        // 80186
        setCurrentInstructionName(() -> "POPA");
        state.setDI(pop());
        state.setSI(pop());
        state.setBP(pop());
        // not restoring SP
        pop();
        state.setBX(pop());
        state.setDX(pop());
        state.setCX(pop());
        state.setAX(pop());
      }
      case 0x62, 0x63, 0x64, 0x65, 0x66, 0x67 -> handleInvalidOpcode(opcode);
      case 0x68 -> {
        // 80186
        int value = this.nextUint16();
        setCurrentInstructionName(() -> "PUSH " + ConvertUtils.toHex16(value));
        push(value);
      }
      case 0x69 -> {
        modRM.read();
        int value = this.nextUint16();
        setCurrentInstructionName(() -> "IMUL16 rm16 " + ConvertUtils.toHex16(value));
        int result = alu.imul16(value, modRM.getRm16());
        modRM.setR16(result);
      }
      case 0x6A -> {
        // 80186
        // sign extend it to 16 bits
        int value = uint16(int8(this.nextUint8()));
        setCurrentInstructionName(() -> "PUSH " + ConvertUtils.toHex16(value));
        push(value);
      }
      case 0x6B -> {
        modRM.read();
        int value = int8(this.nextUint8());
        setCurrentInstructionName(() -> "IMUL8 rm16 " + ConvertUtils.toHex16(value));
        int result = alu.imul16(value, modRM.getRm16());
        modRM.setR16(result);
      }
      case 0x6C, 0x6D, 0x6E, 0x6F -> // INSB, INSW, OUTSB, OUTSW
        processString(opcode);
      case 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F -> jcc(
          opcode);
      case 0x80, // GRP1 rmb ib, GRP1 rmw iw, GRP1 rmb ib, GRP1 rmw ib
      0x81, 0x82, 0x83 -> grp1(opcode);
      case 0x84 -> {
        setCurrentInstructionName(() -> "TEST rmb rb");
        modRM.read();
        alu.and8(modRM.getRm8(), modRM.getR8());
      }
      case 0x85 -> {
        setCurrentInstructionName(() -> "TEST rmw rw");
        modRM.read();
        alu.and16(modRM.getRm16(), modRM.getR16());
      }
      case 0x86 -> {
        setCurrentInstructionName(() -> "XCHG8");
        modRM.read();
        int value1 = modRM.getRm8();
        int value2 = modRM.getR8();
        modRM.setR8(value1);
        modRM.setRm8(value2);
      }
      case 0x87 -> {
        setCurrentInstructionName(() -> "XCHG16");
        modRM.read();
        int value1 = modRM.getRm16();
        int value2 = modRM.getR16();
        modRM.setR16(value1);
        modRM.setRm16(value2);
      }
      case 0x88 -> {
        setCurrentInstructionName(() -> "MOV rmb rb");
        modRM.read();
        modRM.setRm8(modRM.getR8());
      }
      case 0x89 -> {
        setCurrentInstructionName(() -> "MOV rmw rw");
        modRM.read();
        modRM.setRm16(uint16(modRM.getR16()));
      }
      case 0x8A -> {
        setCurrentInstructionName(() -> "MOV rb, rmb");
        modRM.read();
        modRM.setR8(modRM.getRm8());
      }
      case 0x8B -> {
        setCurrentInstructionName(() -> "MOV rw rmw");
        modRM.read();
        modRM.setR16(modRM.getRm16());
      }
      case 0x8C -> {
        setCurrentInstructionName(() -> "MOV rmw sreg");
        modRM.read();
        modRM.setRm16(uint16(modRM.getSegmentRegister()));
      }
      case 0x8D -> {
        setCurrentInstructionName(() -> "LEA");
        modRM.read();
        modRM.setR16(uint16(modRM.getMemoryOffset()));
      }
      case 0x8E -> {
        setCurrentInstructionName(() -> "MOV sreg rmw");
        modRM.read();
        modRM.setSegmentRegister(modRM.getRm16());
      }
      case 0x8F -> {
        setCurrentInstructionName(() -> "POP rmw");
        modRM.read();
        modRM.setRm16(pop());
      }
      case 0x90 -> setCurrentInstructionName(() -> "NOP");
      case 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97 -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "XCHG AX," + state.getRegisters().getRegName(regIndex));
        int value1 = state.getAX();
        int value2 = state.getRegisters().getRegister(regIndex);
        state.setAX(value2);
        state.getRegisters().setRegister(regIndex, value1);
      }
      case 0x98 -> {
        // Convert byte to word
        setCurrentInstructionName(() -> "CBW");
        state.setAX(uint16(int8(state.getAL())));
      }
      case 0x99 -> {
        // Sign extend AX into DX (word to dword)
        setCurrentInstructionName(() -> "CWD");
        if (state.getAX() >= 0x8000) {
          state.setDX(0xFFFF);
        } else {
          state.setDX(0);
        }
      }
      case 0x9A -> { // FAR CALL
        int ip = nextUint16();
        int cs = nextUint16();
        setCurrentInstructionName(() -> "FAR CALL");
        farCall(state.getCS(), internalIp, cs, ip);
      }
      // Do nothing, this is to wait for the FPU which is not implemented
      case 0x9B -> setCurrentInstructionName(() -> "WAIT");
      case 0x9C -> {
        setCurrentInstructionName(() -> "PUSHF");
        push(state.getFlags().getFlagRegister());
      }
      case 0x9D -> {
        setCurrentInstructionName(() -> "POPF");
        state.getFlags().setFlagRegister(pop());
      }
      case 0x9E -> {
        setCurrentInstructionName(() -> "SAHF");
        state.getFlags().setFlagRegister(state.getAH());
      }
      case 0x9F -> {
        setCurrentInstructionName(() -> "LAHF");
        state.setAH(state.getFlags().getFlagRegister());
      }
      case 0xA0 -> {
        setCurrentInstructionName(() -> "MOV AL moffs8");
        state.setAL(memory.getUint8(getDsNextUint16Address()));
      }
      case 0xA1 -> {
        setCurrentInstructionName(() -> "MOV AX moffs16");
        state.setAX(memory.getUint16(getDsNextUint16Address()));
      }
      case 0xA2 -> {
        setCurrentInstructionName(() -> "MOV moffs8 AL");
        memory.setUint8(getDsNextUint16Address(), state.getAL());
      }
      case 0xA3 -> {
        setCurrentInstructionName(() -> "MOV moffs16 AX");
        memory.setUint16(getDsNextUint16Address(), state.getAX());
      }
      case 0xA4, 0xA5, 0xA6, 0xA7 -> processString(opcode);
      case 0xA8 -> {
        setCurrentInstructionName(() -> "TEST AL ib");
        alu.and8(state.getAL(), nextUint8());
      }
      case 0xA9 -> {
        setCurrentInstructionName(() -> "TEST AX iw");
        alu.and16(state.getAX(), nextUint16());
      }
      case 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF -> processString(opcode);
      case 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7 -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "MOV " + state.getRegisters().getReg8Name(regIndex) + " ib");
        state.getRegisters().setRegisterFromHighLowIndex8(regIndex, nextUint8());
      }
      case 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF -> {
        int regIndex = opcode & REG_INDEX_MASK;
        setCurrentInstructionName(() -> "MOV " + state.getRegisters().getRegName(regIndex) + " iw");
        state.getRegisters().setRegister(regIndex, nextUint16());
      }
      case 0xC0 -> {
        modRM.read();
        int count = this.nextUint8();
        int value = modRM.getRm8();
        setCurrentInstructionName(() -> "SHL rmb " + count);
        modRM.setRm8(alu.shl8(value, count));
      }
      case 0xC1 -> {
        modRM.read();
        int count = this.nextUint8();
        int value = modRM.getRm16();
        setCurrentInstructionName(() -> "SHL rmw " + count);
        modRM.setRm16(alu.shl16(value, count));
      }
      case 0xC2 -> {
        int numberOfBytesToPop = nextUint8();
        setCurrentInstructionName(() -> "RET and pop " + numberOfBytesToPop + " bytes");
        nearRet(numberOfBytesToPop);
      }
      case 0xC3 -> {
        setCurrentInstructionName(() -> "RET");
        nearRet(0);
      }
      case 0xC4, 0xC5 -> {
        // Copy segmented address that is in memory (32bits) into DS/ES and the
        // specified register
        modRM.read();
        modRM.setR16(memory.getUint16(modRM.getMemoryAddress()));
        int value = memory.getUint16(modRM.getMemoryAddress() + 2);

        if (opcode == 0xC4) {
          // LES
          setCurrentInstructionName(() -> "LES rw md");
          state.setES(value);
        } else {
          // LDS
          setCurrentInstructionName(() -> "LDS rw md");
          state.setDS(value);
        }
      }
      case 0xC6 -> {
        setCurrentInstructionName(() -> "MOV rmb ib");
        modRM.read();
        modRM.setRm8(nextUint8());
      }
      case 0xC7 -> {
        setCurrentInstructionName(() -> "MOV rmw iw");
        modRM.read();
        modRM.setRm16(nextUint16());
      }
      case 0xC8, 0xC9 -> handleInvalidOpcode(opcode);
      case 0xCA -> {
        int numberOfBytesToPop = nextUint8();
        setCurrentInstructionName(() -> "RETF and pop " + numberOfBytesToPop + " bytes");
        farRet(numberOfBytesToPop);
      }
      case 0xCB -> {
        setCurrentInstructionName(() -> "RETF");
        farRet(0);
      }
      case 0xCC -> {
        setCurrentInstructionName(() -> "INT 3");
        interrupt(3, false);
      }
      case 0xCD -> {
        setCurrentInstructionName(() -> "INT ib");
        interrupt(nextUint8(), false);
      }
      case 0xCE -> {
        setCurrentInstructionName(() -> "INTO");
        if (state.getOverflowFlag()) {
          interrupt(4, false);
        }
      }
      case 0xCF -> {
        setCurrentInstructionName(() -> "IRET");
        interruptRet();
      }
      case 0xD0, 0xD1, 0xD2, 0xD3 -> // GRP2 rmb 1, GRP2 rmw 1, GRP2 rmb CL, GRP2 rmw CL
        grp2(opcode);
      case 0xD4 -> {
        setCurrentInstructionName(() -> "AAM ib");
        int v1 = state.getAL();
        int v2 = nextUint8();
        if (v2 == 0) {
          handleDivisionError();
          break;
        }
        int result = v1 % v2;
        state.setAH(v1 / v2);
        state.setAL(result);
        alu.updateFlags8(result);
      }
      case 0xD5 -> {
        setCurrentInstructionName(() -> "AAD ib");
        int result = uint8(state.getAL() + state.getAH() * nextUint8());
        state.setAL(result);
        state.setAH(0);
        state.getFlags().setFlagRegister(0);
        alu.updateFlags8(result);
      }
      case 0xD6 -> handleInvalidOpcode(opcode);
      case 0xD7 -> {
        setCurrentInstructionName(() -> "XLAT");
        int address = modRM.getAddress(SegmentRegisters.DS_INDEX, state.getBX()) + state.getAL();
        state.setAL(memory.getUint8(address));
      }
      case 0xD8 -> handleInvalidOpcode(opcode);
      case 0xD9 -> {
        modRM.read();
        int groupIndex = modRM.getRegisterIndex();
        switch (groupIndex) {
          case 0x7 -> {
            // Set the control word to the value expected after init since FPU is not supported.
            modRM.setRm16(0x37F);
            setCurrentInstructionName(() -> "FNSTCW");
          }
          default -> throw new InvalidGroupIndexException(machine, groupIndex);
        }
      }
      case 0xDA -> handleInvalidOpcode(opcode);
      case 0xDB -> {
        int opCodeNextByte = nextUint8();
        if (opCodeNextByte != 0xE3) {
          int fullOpCode = (opcode << 8) | opCodeNextByte;
          handleInvalidOpcode(fullOpCode);
        }
        setCurrentInstructionName(() -> "FNINIT");
        // Do nothing, no FPU emulation, but this is used to detect FPU
      }
      case 0xDC -> handleInvalidOpcode(opcode);
      case 0xDD -> {
        modRM.read();
        int groupIndex = modRM.getRegisterIndex();
        switch (groupIndex) {
          case 0x7 -> {
            // Set non zero, means no FPU installed when called after FNINIT.
            modRM.setRm16(0xFF);
            setCurrentInstructionName(() -> "FNSTSW");
          }
          default -> throw new InvalidGroupIndexException(machine, groupIndex);
        }
      }
      case 0xDE, 0xDF -> handleInvalidOpcode(opcode);
      case 0xE0, 0xE1 -> { // LOOPZ / LOOPNZ
        boolean zeroFlag = (opcode & 0x1) == 1;
        int address = int8(nextUint8());
        if (zeroFlag) {
          setCurrentInstructionName(() -> "LOOPZ " + address);
        } else {
          setCurrentInstructionName(() -> "LOOPNZ " + address);
        }
        int cx = state.getCX() - 1;
        state.setCX(cx);
        if (cx != 0 && state.getZeroFlag() == zeroFlag) {
          internalIp += address;
        }
      }
      case 0xE2 -> { // LOOP
        setCurrentInstructionName(() -> "LOOP");
        int address = int8(nextUint8());
        int cx = state.getCX() - 1;
        state.setCX(cx);
        if (cx != 0) {
          internalIp += address;
        }
      }
      case 0xE3 -> // JCXZ
        jcc(opcode);
      case 0xE4 -> {
        int port = nextUint8();
        setCurrentInstructionName(() -> "IN AL " + ConvertUtils.toHex8(port));
        state.setAL(uint8(inb(port)));
      }
      case 0xE5 -> {
        int port = nextUint16();
        setCurrentInstructionName(() -> "IN AL " + ConvertUtils.toHex16(port));
        state.setAX(uint16(inw(port)));
      }
      case 0xE6 -> {
        int port = nextUint8();
        int value = state.getAL();
        setCurrentInstructionName(() -> "OUT " + ConvertUtils.toHex8(port) + " AL=" + ConvertUtils.toHex8(value));
        outb(port, value);
      }
      case 0xE7 -> {
        int port = nextUint16();
        int value = state.getAX();
        setCurrentInstructionName(() -> "OUT " + ConvertUtils.toHex16(port) + " AX=" + ConvertUtils.toHex16(value));
        outw(port, value);
      }
      case 0xE8 -> {
        setCurrentInstructionName(() -> "CALL NEAR");
        int nextInstruction = internalIp + 2;
        int offset = int16(nextUint16());
        int callAddress = uint16(nextInstruction + offset);
        nearCall(nextInstruction, callAddress);
      }
      case 0xE9 -> {
        int offset = int16(nextUint16());
        jumpNear(internalIp + offset);
      }
      case 0xEA -> {
        int ip = nextUint16();
        int cs = nextUint16();
        jumpFar(cs, ip);
      }
      case 0xEB -> {
        int offset = int8(nextUint8());
        jumpNear(internalIp + offset);
      }
      case 0xEC -> {
        int port = state.getDX();
        setCurrentInstructionName(() -> "IN AL DX=" + ConvertUtils.toHex16(port));
        state.setAL(inb(port));
      }
      case 0xED -> {
        int port = state.getDX();
        setCurrentInstructionName(() -> "IN AX DX=" + ConvertUtils.toHex16(port));
        state.setAX(inw(port));
      }
      case 0xEE -> {
        int port = state.getDX();
        int value = state.getAL();
        setCurrentInstructionName(() -> "OUT DX=" + ConvertUtils.toHex16(port) + " AL=" + ConvertUtils.toHex8(value));
        outb(port, value);
      }
      case 0xEF -> {
        int port = state.getDX();
        int value = state.getAX();
        setCurrentInstructionName(() -> "OUT DX=" + ConvertUtils.toHex16(port) + " AX=" + ConvertUtils.toHex16(value));
        outw(port, value);
      }
      case 0xF0, 0xF1 -> handleInvalidOpcode(opcode);
      case 0xF2, 0xF3 -> handleInvalidOpcodeBecausePrefix(opcode);
      case 0xF4 -> {
        setCurrentInstructionName(() -> "HLT");
        LOGGER.info("HLT instruction encountered, halting!");
        this.running = false;
      }
      case 0xF5 -> {
        setCurrentInstructionName(() -> "CMC");
        state.setCarryFlag(!state.getCarryFlag());
      }
      case 0xF6 -> // GRP3a rmb
        grp3a();
      case 0xF7 -> // GRP3b rmw
        grp3b();
      case 0xF8 -> {
        setCurrentInstructionName(() -> "CLC");
        state.setCarryFlag(false);
      }
      case 0xF9 -> {
        setCurrentInstructionName(() -> "STC");
        state.setCarryFlag(true);
      }
      case 0xFA -> {
        setCurrentInstructionName(() -> "CLI");
        state.setInterruptFlag(false);
      }
      case 0xFB -> {
        setCurrentInstructionName(() -> "STI");
        state.setInterruptFlag(true);
      }
      case 0xFC -> {
        setCurrentInstructionName(() -> "CLD");
        state.setDirectionFlag(false);
      }
      case 0xFD -> {
        setCurrentInstructionName(() -> "STD");
        state.setDirectionFlag(true);
      }
      case 0xFE -> // GRP4 rmb
        grp4();
      case 0xFF -> // GRP5 rmw
        grp5();
      default -> handleInvalidOpcode(opcode);
    }
  }

  private void handleInvalidOpcodeBecausePrefix(int opcode) throws InvalidOpcodeException {
    throw new InvalidOpcodeException(machine, opcode, true);
  }

  private void handleInvalidOpcode(int opcode) throws InvalidOpcodeException {
    throw new InvalidOpcodeException(machine, opcode, false);
  }

  private int getDsNextUint16Address() {
    return modRM.getAddress(SegmentRegisters.DS_INDEX, nextUint16());
  }

  private boolean isStringOpUpdatingFlags(int stringOpCode) {
    return stringOpCode == 0xA6 // CMPSB
        || stringOpCode == 0xA7 // CMPSW
        || stringOpCode == 0xAE // SCASB
        || stringOpCode == 0xAF; // SCASW
  }

  /**
   * Jumps handling
   * 
   * @param opcode
   * @throws InvalidOperationException
   */
  private void jcc(int opcode) throws InvalidOperationException {
    int address = int8(nextUint8());
    boolean jump = switch (opcode) {
      case 0x70 -> state.getOverflowFlag();
      case 0x71 -> !state.getOverflowFlag();
      case 0x72 -> state.getCarryFlag();
      case 0x73 -> !state.getCarryFlag();
      case 0x74 -> state.getZeroFlag();
      case 0x75 -> !state.getZeroFlag();
      case 0x76 -> state.getCarryFlag() || state.getZeroFlag();
      case 0x77 -> !state.getCarryFlag() && !state.getZeroFlag();
      case 0x78 -> state.getSignFlag();
      case 0x79 -> !state.getSignFlag();
      case 0x7A -> state.getParityFlag();
      case 0x7B -> !state.getParityFlag();
      case 0x7C -> state.getSignFlag() != state.getOverflowFlag();
      case 0x7D -> state.getSignFlag() == state.getOverflowFlag();
      case 0x7E -> state.getZeroFlag() || state.getSignFlag() != state.getOverflowFlag();
      case 0x7F -> !state.getZeroFlag() && state.getSignFlag() == state.getOverflowFlag();
      case 0xE3 -> state.getCX() == 0;
      default -> throw new InvalidOpcodeException(machine, opcode, false);
    };
    setCurrentInstructionName(() -> switch (opcode) {
      case 0x70 -> "JO";
      case 0x71 -> "JNO";
      case 0x72 -> "JB";
      case 0x73 -> "JNB";
      case 0x74 -> "JZ";
      case 0x75 -> "JNZ";
      case 0x76 -> "JBE";
      case 0x77 -> "JA";
      case 0x78 -> "JS";
      case 0x79 -> "JNS";
      case 0x7A -> "JP";
      case 0x7B -> "JPO";
      case 0x7C -> "JL";
      case 0x7D -> "JGE";
      case 0x7E -> "JNG";
      case 0x7F -> "JG";
      case 0xE3 -> "JCXZ";
      default -> "";
    } + " " + address + " jump?" + jump);
    if (jump) {
      internalIp += address;
    }
  }

  private void grp1(int opcode) throws InvalidOperationException {
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    boolean op1Byte = (opcode & 0b01) == 0;
    boolean op2Byte = (opcode & 0b11) != 1;
    int op2;
    if (op2Byte) {
      if (op1Byte) {
        op2 = nextUint8();
      } else {
        // preserve sign in byte so that it can be extended later if needed
        op2 = uint16(int8(nextUint8()));
      }
    } else {
      op2 = nextUint16();
    }
    int op1 = getRm8Or16(op1Byte);
    setCurrentInstructionName(() -> generateGrp1Name(groupIndex, op1Byte, op1, op2));
    int res;
    if (op1Byte) {
      res = switch (groupIndex) {
        case 0 -> alu.add8(op1, op2);
        case 1 -> alu.or8(op1, op2);
        case 2 -> alu.adc8(op1, op2);
        case 3 -> alu.sbb8(op1, op2);
        case 4 -> alu.and8(op1, op2);
        case 5 -> alu.sub8(op1, op2);
        case 6 -> alu.xor8(op1, op2);
        case 7 -> alu.sub8(op1, op2);
        default -> throw new InvalidGroupIndexException(machine, groupIndex);
      };
    } else {
      res = switch (groupIndex) {
        case 0 -> alu.add16(op1, op2);
        case 1 -> alu.or16(op1, op2);
        case 2 -> alu.adc16(op1, op2);
        case 3 -> alu.sbb16(op1, op2);
        case 4 -> alu.and16(op1, op2);
        case 5 -> alu.sub16(op1, op2);
        case 6 -> alu.xor16(op1, op2);
        case 7 -> alu.sub16(op1, op2);
        default -> throw new InvalidGroupIndexException(machine, groupIndex);
      };
    }
    // 7 is CMP so no memory to set
    if (groupIndex != 7) {
      if (op1Byte) {
        modRM.setRm8(res);
      } else {
        modRM.setRm16(res);
      }
    }
  }

  private String generateGrp1Name(int groupIndex, boolean op1Byte, int op1, int op2) {
    String opName = switch (groupIndex) {
      case 0 -> "ADD";
      case 1 -> "OR";
      case 2 -> "ADC";
      case 3 -> "SBB";
      case 4 -> "AND";
      case 5 -> "SUB";
      case 6 -> "XOR";
      case 7 -> "CMP";
      default -> "";
    };
    return opName + generate8Or16Value(op1Byte, op1, op2);
  }

  private void grp2(int opcode) throws InvalidOperationException {
    // GRP2 rmb 1
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    boolean op1Byte = (opcode & 0b01) == 0;

    boolean valueIsCL = (opcode & 0b10) == 0b10;// if it 0b10, it is CL
    int op2;
    if (valueIsCL) {
      op2 = state.getCL();
    } else {
      op2 = 1;
    }
    int op1 = getRm8Or16(op1Byte);
    setCurrentInstructionName(() -> generateGrp2Name(groupIndex, op1Byte, op1, op2));
    int res;
    if (op1Byte) {
      res = switch (groupIndex) {
        case 0 -> alu.rol8(op1, op2);
        case 1 -> alu.ror8(op1, op2);
        case 2 -> alu.rcl8(op1, op2);
        case 3 -> alu.rcr8(op1, op2);
        case 4 -> alu.shl8(op1, op2);
        case 5 -> alu.shr8(op1, op2);
        case 7 -> alu.sar8(op1, op2);
        default -> throw new InvalidGroupIndexException(machine, groupIndex);
      };
    } else {
      res = switch (groupIndex) {
        case 0 -> alu.rol16(op1, op2);
        case 1 -> alu.ror16(op1, op2);
        case 2 -> alu.rcl16(op1, op2);
        case 3 -> alu.rcr16(op1, op2);
        case 4 -> alu.shl16(op1, op2);
        case 5 -> alu.shr16(op1, op2);
        case 7 -> alu.sar16(op1, op2);
        default -> throw new InvalidGroupIndexException(machine, groupIndex);
      };
    }
    if (op1Byte) {
      modRM.setRm8(res);
    } else {
      modRM.setRm16(res);
    }
  }

  private int getRm8Or16(boolean op1Byte) {
    if (op1Byte) {
      return modRM.getRm8();
    }
    return modRM.getRm16();
  }

  private String generateGrp2Name(int groupIndex, boolean op1Byte, int op1, int op2) {
    String opName = switch (groupIndex) {
      case 0 -> "ROL";
      case 1 -> "ROR";
      case 2 -> "RCL";
      case 3 -> "RCR";
      case 4 -> "SHL";
      case 5 -> "SHR";
      case 7 -> "SAR";
      default -> "";
    };
    return opName + generate8Or16Value(op1Byte, op1, op2);
  }

  private String generate8Or16Value(boolean op1Byte, int op1, int op2) {
    String params = "(" + ConvertUtils.toHex8(op1) + "," + ConvertUtils.toHex8(op2) + ")";
    if (op1Byte) {
      return "8 " + params;
    }
    return "16 " + params;
  }

  private void grp3a() throws InvalidOperationException {
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    switch (groupIndex) {
      case 0 -> {
        setCurrentInstructionName(() -> "TEST8");
        alu.and8(modRM.getRm8(), nextUint8());
      }
      case 2 -> {
        setCurrentInstructionName(() -> "NOT8");
        modRM.setRm8(uint8(~modRM.getRm8()));
      }
      case 3 -> {
        setCurrentInstructionName(() -> "NEG8");
        int value = modRM.getRm8();
        value = alu.sub8(0, value);
        modRM.setRm8(value);
        state.setCarryFlag(value != 0);
      }
      case 4 -> {
        setCurrentInstructionName(() -> "MUL8");
        int result = alu.mul8(state.getAL(), modRM.getRm8());
        // Upper part of the result goes in AH
        state.setAH(uint8(result >> 8));
        state.setAL(uint8(result));
      }
      case 5 -> {
        setCurrentInstructionName(() -> "IMUL8");
        int result = alu.imul8(state.getAL(), modRM.getRm8());
        // Upper part of the result goes in AH
        state.setAH(uint8(result >> 8));
        state.setAL(uint8(result));
      }
      case 6 -> {
        setCurrentInstructionName(() -> "DIV8");
        int v1 = state.getAX();
        int v2 = modRM.getRm8();
        Integer result = alu.div8(v1, v2);
        if (result == null) {
          handleDivisionError();
          break;
        }
        state.setAL(result);
        state.setAH(v1 % v2);
      }
      case 7 -> {
        setCurrentInstructionName(() -> "IDIV8");
        int v1 = int16(state.getAX());
        int v2 = int8(modRM.getRm8());
        Integer result = alu.idiv8(v1, v2);
        if (result == null) {
          handleDivisionError();
          break;
        }
        state.setAL(result);
        state.setAH(int16(v1) % int8(v2));
      }
      default -> throw new InvalidGroupIndexException(machine, groupIndex);
    }
  }

  private void handleDivisionError() throws UnhandledOperationException {
    // Reset IP because instruction is not finished (this is how an actual CPU behaves)
    internalIp = state.getIP();
    interrupt(0, false);
  }

  private void grp3b() throws InvalidOperationException {
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    switch (groupIndex) {
      case 0 -> {
        setCurrentInstructionName(() -> "TEST16");
        alu.and16(modRM.getRm16(), nextUint16());
      }
      case 2 -> {
        setCurrentInstructionName(() -> "NOT16");
        modRM.setRm16(uint16(~modRM.getRm16()));
      }
      case 3 -> {
        setCurrentInstructionName(() -> "NEG16");
        int value = modRM.getRm16();
        value = alu.sub16(0, value);
        modRM.setRm16(value);
        state.setCarryFlag(value != 0);
      }
      case 4 -> {
        setCurrentInstructionName(() -> "MUL16");
        int result = alu.mul16(state.getAX(), modRM.getRm16());
        // Upper part of the result goes in DX
        state.setDX(result >>> 16);
        state.setAX(result);
      }
      case 5 -> {
        setCurrentInstructionName(() -> "IMUL16");
        int result = alu.imul16(state.getAX(), modRM.getRm16());
        // Upper part of the result goes in DX
        state.setDX(result >>> 16);
        state.setAX(result);
      }
      case 6 -> {
        setCurrentInstructionName(() -> "DIV16");
        int v1 = (state.getDX() << 16) | state.getAX();
        int v2 = modRM.getRm16();
        Integer result = alu.div16(v1, v2);
        if (result == null) {
          handleDivisionError();
          break;
        }
        state.setAX(result);
        state.setDX((int)(uint32(v1) % uint32(v2)));
      }
      case 7 -> {
        setCurrentInstructionName(() -> "IDIV16");
        // no sign extension for v1 as it is already a 32bit value
        int v1 = (state.getDX() << 16) | state.getAX();
        int v2 = int16(modRM.getRm16());
        Integer result = alu.idiv16(v1, v2);
        if (result == null) {
          handleDivisionError();
          break;
        }
        state.setAX(result);
        state.setDX(v1 % v2);
      }
      default -> throw new InvalidGroupIndexException(machine, groupIndex);
    }

  }

  private void grp4() throws InvalidOperationException {
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    switch (groupIndex) {
      case 0 -> {
        setCurrentInstructionName(() -> "INC");
        modRM.setRm8(alu.inc8(modRM.getRm8()));
      }
      case 1 -> {
        setCurrentInstructionName(() -> "DEC");
        modRM.setRm8(alu.dec8(modRM.getRm8()));
      }
      case 7 ->
        // Callback, emulator specific instruction FE38 like in dosbox to allow interrupts to be overridden by the
        // program
        callback(this.nextUint16());
      default -> throw new InvalidGroupIndexException(machine, groupIndex);
    }
  }

  private void grp5() throws InvalidOperationException {
    modRM.read();
    int groupIndex = modRM.getRegisterIndex();
    switch (groupIndex) {
      case 0 -> {
        setCurrentInstructionName(() -> "INC");
        modRM.setRm16(alu.inc16(modRM.getRm16()));
      }
      case 1 -> {
        setCurrentInstructionName(() -> "DEC");
        modRM.setRm16(alu.dec16(modRM.getRm16()));
      }
      case 2 -> {
        setCurrentInstructionName(() -> "NEAR CALL");
        int callAddress = modRM.getRm16();
        nearCall(internalIp, callAddress);
      }
      case 3 -> {
        setCurrentInstructionName(() -> "FAR CALL");
        int ipAddress = modRM.getMemoryAddress();
        int ip = memory.getUint16(ipAddress);
        int cs = memory.getUint16(ipAddress + 2);
        farCall(state.getCS(), internalIp, cs, ip);
      }
      case 4 -> {
        int ip = modRM.getRm16();
        jumpNear(ip);
      }
      case 5 -> {
        int ipAddress = modRM.getMemoryAddress();
        int ip = memory.getUint16(ipAddress);
        int cs = memory.getUint16(ipAddress + 2);
        jumpFar(cs, ip);
      }
      case 6 -> {
        setCurrentInstructionName(() -> "PUSH");
        push(modRM.getRm16());
      }
      default -> throw new InvalidGroupIndexException(machine, groupIndex);
    }
  }

  private void jumpNear(int ip) {
    setCurrentInstructionName(
        () -> "JMP NEAR " + ConvertUtils.toSegmentedAddressRepresentation(state.getCS(), ip));
    handleJump(state.getCS(), ip);
  }

  private void jumpFar(int cs, int ip) {
    setCurrentInstructionName(
        () -> "JMP FAR " + ConvertUtils.toSegmentedAddressRepresentation(cs, ip));
    handleJump(cs, ip);
  }

  private void handleJump(int cs, int ip) {
    internalIp = ip;
    state.setCS(cs);
  }

  private void nearCall(int returnIP, int callIP) {
    push(returnIP);
    internalIp = callIP;
    handleCall(CallType.NEAR, state.getCS(), returnIP, state.getCS(), callIP);
  }

  private void farCall(int returnCS, int returnIP, int targetCS, int targetIP) {
    push(returnCS);
    push(returnIP);
    state.setCS(targetCS);
    internalIp = targetIP;
    handleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
  }

  private void handleCall(CallType callType, int returnCS, int returnIP, int targetCS, int targetIP) {
    if (isLoggingEnabled()) {
      LOGGER.debug("CALL {}, will return to {}", ConvertUtils.toSegmentedAddressRepresentation(targetCS, targetIP),
          ConvertUtils.toSegmentedAddressRepresentation(returnCS, returnIP));
    }
    functionHandlerInUse.call(callType, targetCS, targetIP, returnCS, returnIP);
  }

  public void nearRet(int numberOfBytesToPop) {
    functionHandlerInUse.ret(CallType.NEAR);
    internalIp = pop();
    state.setSP(numberOfBytesToPop + state.getSP());
  }

  public void farRet(int numberOfBytesToPop) {
    functionHandlerInUse.ret(CallType.FAR);
    internalIp = pop();
    state.setCS(pop());
    state.setSP(numberOfBytesToPop + state.getSP());
  }

  private boolean isStringOpcode(int opcode) {
    return STRING_OPCODES.contains(opcode);
  }

  private boolean isPrefix(int opcode) {
    return PREFIXES_OPCODES.contains(opcode);
  }

  private void processString(int opcode) throws InvalidOperationException {
    int diff = (state.getDirectionFlag() ? -1 : 1) << (opcode & 1);

    switch (opcode) {
      case 0xA4 -> {
        setCurrentInstructionName(() -> "MOVSB");
        int value = memory.getUint8(getMemoryAddressOverridableDsSi());
        memory.setUint8(getMemoryAddressEsDi(), value);
        state.setSI(state.getSI() + diff);
        state.setDI(state.getDI() + diff);
      }
      case 0xA5 -> {
        setCurrentInstructionName(() -> "MOVSW");
        int value = memory.getUint16(getMemoryAddressOverridableDsSi());
        memory.setUint16(getMemoryAddressEsDi(), value);
        state.setSI(state.getSI() + diff);
        state.setDI(state.getDI() + diff);
      }
      case 0xA6 -> {
        setCurrentInstructionName(() -> "CMPSB");
        int value = memory.getUint8(getMemoryAddressOverridableDsSi());
        alu.sub8(value, memory.getUint8(getMemoryAddressEsDi()));
        state.setSI(state.getSI() + diff);
        state.setDI(state.getDI() + diff);
      }
      case 0xA7 -> {
        setCurrentInstructionName(() -> "CMPSW");
        int value = memory.getUint16(getMemoryAddressOverridableDsSi());
        alu.sub16(value, memory.getUint16(getMemoryAddressEsDi()));
        state.setSI(state.getSI() + diff);
        state.setDI(state.getDI() + diff);
      }
      case 0xAA -> {
        setCurrentInstructionName(() -> "STOSB");
        memory.setUint8(getMemoryAddressEsDi(), state.getAL());
        state.setDI(state.getDI() + diff);
      }
      case 0xAB -> {
        setCurrentInstructionName(() -> "STOSW");
        memory.setUint16(getMemoryAddressEsDi(), state.getAX());
        state.setDI(state.getDI() + diff);
      }
      case 0xAC -> {
        setCurrentInstructionName(() -> "LODSB");
        int value = memory.getUint8(getMemoryAddressOverridableDsSi());
        state.setAL(value);
        state.setSI(state.getSI() + diff);
      }
      case 0xAD -> {
        setCurrentInstructionName(() -> "LODSW");
        int value = memory.getUint16(getMemoryAddressOverridableDsSi());
        state.setAX(value);
        state.setSI(state.getSI() + diff);
      }
      case 0xAE -> {
        setCurrentInstructionName(() -> "SCASB");
        alu.sub8(state.getAL(), memory.getUint8(getMemoryAddressEsDi()));
        state.setDI(state.getDI() + diff);
      }
      case 0xAF -> {
        setCurrentInstructionName(() -> "SCASW");
        alu.sub16(state.getAX(), memory.getUint16(getMemoryAddressEsDi()));
        state.setDI(state.getDI() + diff);
      }
      case 0x6C -> {
        setCurrentInstructionName(() -> "INSB");
        int port = state.getDX();
        int value = inb(port);
        memory.setUint8(getMemoryAddressEsDi(), value);
        state.setSI(state.getSI() + diff);
      }
      case 0x6D -> {
        setCurrentInstructionName(() -> "INSW");
        int port = state.getDX();
        int value = inw(port);
        memory.setUint16(getMemoryAddressEsDi(), value);
        state.setSI(state.getSI() + diff);
      }
      case 0x6E -> {
        setCurrentInstructionName(() -> "OUTSB");
        int port = state.getDX();
        int value = memory.getUint8(getMemoryAddressOverridableDsSi());
        outb(port, value);
        state.setSI(state.getSI() + diff);
      }
      case 0x6F -> {
        setCurrentInstructionName(() -> "OUTSW");
        int port = state.getDX();
        int value = memory.getUint16(getMemoryAddressOverridableDsSi());
        outw(port, value);
        state.setSI(state.getSI() + diff);
      }
      default -> handleInvalidOpcode(opcode);
    }
  }

  private int getMemoryAddressOverridableDsSi() {
    return modRM.getAddress(SegmentRegisters.DS_INDEX, state.getSI());
  }

  private int getMemoryAddressEsDi() {
    return MemoryUtils.toPhysicalAddress(state.getES(), state.getDI());
  }

  private void push(int value) {
    int sp = uint16(state.getSP() - 2);
    state.setSP(sp);
    memory.setUint16(state.getStackPhysicalAddress(), value);
  }

  private int pop() {
    int res = memory.getUint16(state.getStackPhysicalAddress());
    state.setSP(state.getSP() + 2);
    return res;
  }

  private void outb(int port, int val) throws InvalidOperationException {
    if (ioPortDispatcher != null) {
      ioPortDispatcher.outb(uint16(port), uint8(val));
    }
  }

  private void outw(int port, int val) throws InvalidOperationException {
    if (ioPortDispatcher != null) {
      ioPortDispatcher.outw(uint16(port), uint16(val));
    }
  }

  private int inb(int port) throws InvalidOperationException {
    if (ioPortDispatcher != null) {
      return uint8(ioPortDispatcher.inb(uint16(port)));
    }
    return 0;
  }

  private int inw(int port) throws InvalidOperationException {
    if (ioPortDispatcher != null) {
      return uint16(ioPortDispatcher.inw(uint16(port)));
    }
    return 0;
  }

  private void interrupt(int vectorNumber, boolean external) throws UnhandledOperationException {
    int targetIP = memory.getUint16(4 * vectorNumber);
    int targetCS = memory.getUint16(4 * vectorNumber + 2);
    if (errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
      throw new UnhandledOperationException(machine,
          "Int was called but vector was not initialized for vectorNumber=" + ConvertUtils.toHex(vectorNumber));
    }
    int returnCS = state.getCS();
    int returnIP = internalIp;
    if (isLoggingEnabled()) {
      LOGGER.debug("int {} handler found in memory, {}", ConvertUtils.toHex(vectorNumber),
          ConvertUtils.toSegmentedAddressRepresentation(targetCS, targetIP));
    }
    push(state.getFlags().getFlagRegister());
    push(returnCS);
    push(returnIP);
    state.setInterruptFlag(false);
    internalIp = targetIP;
    state.setCS(targetCS);
    boolean recordReturn = true;
    if (external) {
      this.functionHandlerInUse = functionHandlerInExternalInterrupt;
      recordReturn = false;
    }
    this.functionHandlerInUse.icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber,
        recordReturn);
  }

  public void interruptRet() {
    this.functionHandlerInUse.ret(CallType.INTERRUPT);
    internalIp = pop();
    state.setCS(pop());
    state.getFlags().setFlagRegister(pop());
    this.functionHandlerInUse = functionHandler;
  }

  public void setFlagOnInterruptStack(int flagMask, boolean flagValue) {
    int flagsAddress = MemoryUtils.toPhysicalAddress(state.getSS(), state.getSP() + 4);
    int value = memory.getUint16(flagsAddress);
    if (flagValue) {
      value = value | flagMask;
    } else {
      value = value & ~flagMask;
    }
    memory.setUint16(flagsAddress, value);
  }

  private void callback(int callbackIndex) throws UnhandledOperationException {
    setCurrentInstructionName(() -> "CALLBACK " + callbackIndex);
    if (isLoggingEnabled()) {
      LOGGER.debug("callback {}", ConvertUtils.toHex16(callbackIndex));
    }
    callbackHandler.run(callbackIndex);
  }

  public int nextUint8() {
    int res = memory.getUint8(getInternalIpPhysicalAddress());
    internalIp++;
    return res;
  }

  public int nextUint16() {
    int res = memory.getUint16(getInternalIpPhysicalAddress());
    internalIp += 2;
    return res;
  }

  private int getInternalIpPhysicalAddress() {
    return MemoryUtils.toPhysicalAddress(state.getCS(), internalIp);
  }
}
